(in-package :cl-wfx)

;;NOTE to SELF: If anything in the code/design looks 
;;over complicated ask yourself it makes running multiple
;;systems and system instances possible!!!!

;;NOTE to SELF: Be clear in code about what is a method 
;;that directly affects an object and an event that has 
;;to be handled by the object, events could use direct 
;;methods though but that just makes the code less clear 
;;about its purpose.!!!


;;TODO: Consider system logging of user actions and non user 
;;actions. User actions can go around widget event handlers.
;;How to get current user?

;;TODOO Consider how logging of db/data related actions can 
;;be used for rollbacks!!!Add function to see user actions.


;;TODO: System messages to communicate with non active users. 
;;Emails? Messages logged while ofline?
;;TODO: Users to be able to comm with system regarding system messages?
;;TODO: Users comms with each other?
;;TODO: Users to comms with system? In system and out of system? 
;;Mails, sms and restless api.
;;TODO: Restless api integrated into core? When creating 
;;event-handlers create api calls to accomplish same job?
;;TODO: Add script-class to log allowed functions. Add 
;;allowed functions to script class as well to dynamically add or remove access



(defclass system ()
  ((system-name :initarg :system-name
		:accessor system-name
		:initform nil
		:documentation "Name of the system")  
   (system-status :initarg :system-status
		  :accessor system-status
		  :initform nil
		  :documentation		  
		  ":initialized :stopped :started :locked")
   (system-folder :initarg :system-folder
		  :accessor system-folder
		  :initform "/system/"
		  :documentation		  
		  "Path where files generated by the system should be stored.")  
   (licenses :initarg :licenses
	     :accessor licenses
	     :initform nil
	     :documentation	     
	     "Licenses registered with the system.")
   (data :initarg data
	     :accessor data
	     :initform nil
	     :documentation	     
	     "The object that handles data persistance.") 

   (modules :initarg :modules
	    :accessor system-modules
	    :initform nil)
   (sessions :initarg :sessions
	     :accessor sessions
	     :initform (make-hash-table :test #'equalp))
   (debug-errors-p :initarg :debug-errors-p
		   :accessor debug-errors-p
		   :initform nil
		   :documentation "To put the system into debug mode while running.")
   (logging-p :initarg :logging-p
              :initform nil
              :accessor logging-p
	      :documentation "Indicate if logging should happen at run time.")
   )
  (:documentation   
"This is an conceptual framework to help package
the functionality of an application. Most systems
with a ui have the same basic structure/needs."))


(defclass web-system (system) 
  ((web-folder :initarg :web-folder
	       :accessor web-folder
	       :initform "/web/")
   (system-web-folder :initarg :system-web-folder
	       :accessor system-web-folder
	       :initform "/web/")
   ))

(defmacro with-system (system &body body)
  :documentation "Makes *system* available."
  `(let ((*system* ,system))
     ,@body))

(defgeneric init-sys-data (system &key &allow-other-keys)
  (:documentation "Initialize data storage for system.
Notes:
This is called on initialize-instance :after for system."))

(defmethod init-sys-data :after ((system system) &key &allow-other-keys)
  (dolist (spec *data-specs*)
    ;;TODO: check for existing first
    (let ((old-spec (get-data-spec (name spec)) ))
      (unless old-spec
	(persist-data spec :collection-name "data-specs" 
		      :license-code *sys-license-code*))
      (when old-spec 
	(unless (equalp (script old-spec) (script spec))
	  (setf (script old-spec) (script spec))
	  (persist-data old-spec :collection-name "data-specs" 
			:license-code *sys-license-code*)))))
  (setf *data-specs* nil))

(defgeneric init-system (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system initialization tasks.
Notes:
This is called on initialize-instance :after for system."))

(defmethod  init-system ((system system) &key &allow-other-keys)
  (unless (system-folder system)
    (setf (system-folder system) (format nil "~~/~A" (id-string (system-name system))))
    (ensure-directories-exist (system-folder system))))

(defmethod initialize-instance :after ((system system) &rest args)  
  (declare (ignore args))
  :documentation "Dont mess with this just use init-system and init-sys-data effectively."
  (let ((*system* system))
    (init-system system)  
    (init-sys-data system))
  (setf (system-status system) :initialized))

(defgeneric start-sys (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system startup tasks.
Notes:
Must be called by the framework implementer to get a system going.
Calls in order:
 setup-data
 load-context-specs
 load-modules"))

(defgeneric load-modules (system &key &allow-other-keys))

(defmethod load-modules ((system system) &key &allow-other-keys))

(defun get-context-spec (context-name)
  (fetch-item "context-specs"
	      :test (lambda (spec)
		     (string-equal context-name (name spec)))))


(defun make-menu-item (name context-spec)
  (make-instance 
   'menu-item
   :item-name name
   :context-spec 
   context-spec))

(defgeneric setup-context-login (module context-spec system))

(defmethod load-modules :around ((system system) &key &allow-other-keys)

  (let ((sys-mod (get-module "System Admin")))
    
    (unless sys-mod
      (setf sys-mod
	    (make-instance 
	     'module :module-name "System Admin"
	     :module-short "sys"
	     :menu (list (make-instance 
			  'menu :menu-name "System")))))
    (setf (contexts sys-mod)
	  (remove-if #'not (list
			    ;;  (get-context-spec "theme")
			    (get-context-spec "Allsorts")
			    ;; (get-context-spec "script")
			    ;; (get-context-spec "repl")
			    (get-context-spec "Data Specs")
			    (get-context-spec "Context Specs")
			    ;;  (get-context-spec "report")
			    ;; (get-context-spec "report-view")
			    (get-context-spec "Modules")
			    (get-context-spec "Licenses")
			    (get-context-spec "Entities")
			    (get-context-spec "Users")
			    ;; (get-context-spec "import-data")
			    
			    )))
    
    
    (setup-context-login sys-mod (get-context-spec "Login") *system*)
    
    (dolist (spec (contexts sys-mod))
            ;;TODO: sort out module shit
      (setup-context sys-mod spec *system*))
    
    (let ((menu-items (loop for spec in (contexts sys-mod)
			 when spec
			 collect (make-menu-item (name spec)
						 spec))))
      
      (setf menu-items (append menu-items
			       (list (make-instance 
				      'menu-item
				      :item-name "Logout"
				      :context-spec 
				      (get-context-spec "Login")
				      :context-parameters 
				      (list  (make-instance 'context-parameter
							    :parameter-name "action"
							    :parameter-value "logout"))
				      ))))
      
      (setf (menu-items (first (menu sys-mod)))  menu-items))
    
    ;;TODO: Persist only if nothing has changed!!!!!This is racking up to many 
    ;; versions!!!!!
 
    (persist-data sys-mod
		   :collection-name "modules" 
		   :license-code *sys-license-code*
		   )))



(defgeneric load-context-specs (system &key &allow-other-keys))

(defmethod load-context-specs :before ((system system) &key &allow-other-keys)
	    
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Login"
     :permissions (:update :delete)
     :for-everyone t 
     ))
  
   
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    
    (:context-spec
     :name "Data Specs"
     :permissions (:update :delete :search)
     :for-everyone t 
     (:data-spec :name data-spec)))
  
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Context Specs"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name context-spec)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Modules"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name module)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Licenses"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name license)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Entities"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name entity)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Users"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name user)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Allsorts"
     :permissions (:update :delete)
     :for-everyone t 
     (:data-spec :name allsort)))
  

  )

	    
  

(defmethod start-sys :around ((system system) &key &allow-other-keys)
  (when (or (not (system-status system)) 
	    (equalp (system-status system) :initialized) 
	    (equalp (system-status system) :stopped) )

    (call-next-method)))

(defmethod start-sys :after ((system system) &key &allow-other-keys)
  (let ((*system* system))
    (declare (special *system*))
    
    (system-license)
    
    (load-context-specs system)
    
    (load-modules system)
    
    (setf (system-status system) :started)))


(defgeneric stop-sys (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system cleanup tasks.
Notes:
Calls tear-down-data to clean up data."))

(defmethod stop-sys ((system system) &key &allow-other-keys))

(defmethod stop-sys :before ((system system) &key &allow-other-keys)
  (tear-down-data (data system)))

(defmethod stop-sys :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :started))


;;TODO: How to force lock, how to stop users or more by system lock so that only admin can perform tasks on the system?"
(defgeneric lock (system &key &allow-other-keys)
  (:documentation "Implement system lock tasks."))

(defmethod lock ((system system) &key &allow-other-keys))

(defmethod lock :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :locked))

(defgeneric unlock (system &key &allow-other-keys)
  (:documentation "Implement system unlock tasks."))

(defmethod unlock ((system system) &key &allow-other-keys))

(defmethod unlock :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :started))

