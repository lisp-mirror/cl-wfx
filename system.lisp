(in-package :cl-wfx)

;;NOTE to SELF: If anything in the code/design looks 
;;over complicated ask yourself it makes running multiple
;;systems and system instances possible!!!!

;;NOTE to SELF: Be clear in code about what is a method 
;;that directly affects an object and an event that has 
;;to be handled by the object, events could use direct 
;;methods though but that just makes the code less clear 
;;about its purpose.!!!


;;TODO: Consider system logging of user actions and non user 
;;actions. User actions can go around widget event handlers.
;;How to get current user?

;;TODOO Consider how logging of db/data related actions can 
;;be used for rollbacks!!!Add function to see user actions.


;;TODO: System messages to communicate with non active users. 
;;Emails? Messages logged while ofline?
;;TODO: Users to be able to comm with system regarding system messages?
;;TODO: Users comms with each other?
;;TODO: Users to comms with system? In system and out of system? 
;;Mails, sms and restless api.
;;TODO: Restless api integrated into core? When creating 
;;event-handlers create api calls to accomplish same job?
;;TODO: Add script-class to log allowed functions. Add 
;;allowed functions to script class as well to dynamically add or remove access



(defclass system ()
  ((system-name :initarg :system-name
		:accessor system-name
		:initform nil
		:documentation "Name of the system")  
   (system-status :initarg :system-status
		  :accessor system-status
		  :initform nil
		  :documentation		  
		  ":initialized :stopped :started :locked")
   (system-folder :initarg :system-folder
		  :accessor system-folder
		  :initform "/system/"
		  :documentation		  
		  "Path where files generated by the system should be stored.")  
   (licenses :initarg :licenses
	     :accessor licenses
	     :initform nil
	     :documentation	     
	     "Licenses registered with the system.")
   (data :initarg data
	     :accessor data
	     :initform nil
	     :documentation	     
	     "The object that handles data persistance.") 

   (modules :initarg :modules
	    :accessor system-modules
	    :initform nil)
   (sessions :initarg :sessions
	     :accessor sessions
	     :initform (make-hash-table :test #'equalp))
   (debug-errors-p :initarg :debug-errors-p
		   :accessor debug-errors-p
		   :initform nil
		   :documentation "To put the system into debug mode while running.")
   (logging-p :initarg :logging-p
              :initform nil
              :accessor logging-p
	      :documentation "Indicate if logging should happen at run time.")
   )
  (:documentation   
"This is an conceptual framework to help package
the functionality of an application. Most systems
with a ui have the same basic structure/needs."))


(defclass web-system (system) 
  ((web-folder :initarg :web-folder
	       :accessor web-folder
	       :initform "/web/")))

(defmacro with-system (system &body body)
  :documentation "Makes *system* available."
  `(let ((*system* ,system))
     ,@body))

(defgeneric init-sys-data (system &key &allow-other-keys)
  (:documentation "Initialize data storage for system.
Notes:
This is called on initialize-instance :after for system."))

(defmethod init-sys-data :after ((system system) &key &allow-other-keys)
  (dolist (spec *data-specs*)
    ;;TODO: check for existing first
    (let ((old-spec (get-data-spec (name spec)) ))
      (unless old-spec
	(persist-data spec))
      (when old-spec 
	(unless (equalp (script old-spec) (script spec))
	  (setf (script old-spec) (script spec))
	  (persist-data old-spec)))))
  (setf *data-specs* nil))

(defgeneric init-system (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system initialization tasks.
Notes:
This is called on initialize-instance :after for system."))

(defmethod  init-system ((system system) &key &allow-other-keys)
  (unless (system-folder system)
    (setf (system-folder system) (format nil "~~/~A" (id-string (system-name system))))
    (ensure-directories-exist (system-folder system))))

(defmethod initialize-instance :after ((system system) &rest args)  
  (declare (ignore args))
  :documentation "Dont mess with this just use init-system and init-sys-data effectively."
  (let ((*system* system))
    (init-system system)   
    (init-sys-data system))
  (setf (system-status system) :initialized))

(defgeneric start-sys (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system startup tasks.
Notes:
Must be called by the framework implementer to get a system going.
Calls in order:
 setup-data
 load-context-specs
 load-modules"))

(defgeneric load-modules (system &key &allow-other-keys))

(defmethod load-modules ((system system) &key &allow-other-keys))

(defun get-context-spec (context-name)
  (fetch-item "context-specs"
	      :test (lambda (spec)
		     (string-equal context-name (name spec)))))


;;Not using other data fetch mechanisms because they rely on 
;;get-data-spec so goes into infinite loop
(defun get-data-spec (name-or-col)  
  
  (let ((items (concatenate 
		'vector 
		(remove-if (lambda (doc)
			     (find doc (license-data-items "data-specs") 
				   :test (lambda (doc tdoc)
					   (string-equal (name doc) (name tdoc)))))
			   (system-data-items "data-specs")) 
		(license-data-items "data-specs"))))
    
    (map
     nil
     (lambda (spec)
       (when (or (string-equal name-or-col (name spec))
		 (string-equal name-or-col (collection-name spec))
		 )
		    (return-from get-data-spec spec)))
     items)))



(defun make-menu-item (name context-spec)
  (make-instance 
   'menu-item
   :item-name name
   :context-spec 
   context-spec))

(defmethod load-modules :around ((system system) &key &allow-other-keys)

  (let ((sys-mod (fetch-item "modules"
			     :test (lambda (doc)
				     (string-equal "System Admin" (module-name doc))))))
    
    (unless sys-mod
      (setf sys-mod
	    (make-instance 
	     'module :module-name "System Admin"
	     :module-short "sys"
	     :menu (list (make-instance 
			  'menu :menu-name "System")))))
    (setf (contexts sys-mod)
	  (list
	 ;;  (get-context-spec "theme")
	  (get-context-spec "Allsorts")
	  ;; (get-context-spec "script")
	  ;; (get-context-spec "repl")
	   (get-context-spec "Data Specs")
	   (get-context-spec "Context Specs")
	 ;;  (get-context-spec "report")
	  ;; (get-context-spec "report-view")
	  (get-context-spec "Modules")
	  (get-context-spec "Licenses")
	  (get-context-spec "Users")
	  ;; (get-context-spec "import-data")
	  
	   ))
    
    (setup-context-login sys-mod (get-context-spec "Login") *system*)
    
    (dolist (spec (contexts sys-mod))
            ;;TODO: sort out module shit
      (setup-context sys-mod spec *system*))
    
    (setf (menu-items (first (menu sys-mod)))
	  (loop for spec in (contexts sys-mod)
	       when spec
	     collect (make-menu-item (name spec)
				     spec
				     )))

    ;;TODO: Persist only if nothing has changed!!!!!This is racking up to many 
    ;; versions!!!!!
 
    (persist-data sys-mod)))



(defgeneric load-context-specs (system &key &allow-other-keys))

(defmethod load-context-specs :before ((system system) &key &allow-other-keys)
	    
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Login"
     :permission (:update :delete)
     :for-everyone t 
     ))
  
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    
    (:context-spec
     :name "Data Specs"
     :permission (:update :delete :search)
     :for-everyone t 
     (:data-spec :name data-spec)))
  
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Context Specs"
     :permission (:update :delete)
     :for-everyone t 
     (:data-spec :name context-spec)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Modules"
     :permission (:update :delete)
     :for-everyone t 
     (:data-spec :name module)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Licenses"
     :permission (:update :delete)
     :for-everyone t 
     (:data-spec :name license)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Users"
     :permission (:update :delete)
     :for-everyone t 
     (:data-spec :name user)))
  
  (monkey-lisp:monkey-lisp (:processor-class cl-wfx::context-spec-processor)
    (:context-spec
     :name "Allsorts"
     :permission (:update :delete)
     :for-everyone t 
     (:data-spec :name allsort)))
  

  )

	    
  

(defmethod start-sys :around ((system system) &key &allow-other-keys)
  (when (or (not (system-status system)) 
	    (equalp (system-status system) :initialized) 
	    (equalp (system-status system) :stopped) )

    (call-next-method)))

(defmethod start-sys :after ((system system) &key &allow-other-keys)
  (let ((*system* system))
    (declare (special *system*))
    
    (system-license)
    
    (load-context-specs system)
    
    (load-modules system)
    
    (setf (system-status system) :started)))


(defgeneric stop-sys (system &key &allow-other-keys)
  (:documentation "Method to be used to implement system cleanup tasks.
Notes:
Calls tear-down-data to clean up data."))

(defmethod stop-sys ((system system) &key &allow-other-keys))

(defmethod stop-sys :before ((system system) &key &allow-other-keys)
  (tear-down-data (data system)))

(defmethod stop-sys :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :started))


;;TODO: How to force lock, how to stop users or more by system lock so that only admin can perform tasks on the system?"
(defgeneric lock (system &key &allow-other-keys)
  (:documentation "Implement system lock tasks."))

(defmethod lock ((system system) &key &allow-other-keys))

(defmethod lock :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :locked))

(defgeneric unlock (system &key &allow-other-keys)
  (:documentation "Implement system unlock tasks."))

(defmethod unlock ((system system) &key &allow-other-keys))

(defmethod unlock :after ((system system) &key &allow-other-keys)
  (setf (system-status system) :started))

